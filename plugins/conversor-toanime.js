
//⌬──────────────────────────────────────
//┃  ༒ 𝑫𝑬𝑽𝑬𝑳𝑶𝑷𝑬𝑫 𝑩𝒀 𝑯𝑬𝑵𝑹𝒀 𝑨𝑹𝑪𝑨𝑵𝑮𝑬𝑳𝑶  ༒
//┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
//┃ ✞ঔৣ 𝙿𝚕𝚎𝚊𝚜𝚎 𝚌𝚛𝚎𝚍𝚒𝚝 𝚒𝚏 𝚢𝚘𝚞 𝚞𝚜𝚎 𝚝𝚑𝚎 𝚌𝚘𝚍𝚎 ঔৣ✞
//┃ 𖤍 𝘾𝙤𝙣𝙩𝙖𝙘𝙩-𝙢𝙚 𝙛𝙤𝙧 𝙖𝙣𝙮 𝙙𝙤𝙪𝙗𝙩
// ╰─...⌬─────────────────────────────────



/* efeitos createCanvas


[22/01, 10:27] 𝙷𝚎𝚗𝚛𝚢 𝙰𝚛𝚌𝚊𝚗𝚐𝚎𝚕𝚘: {
  "status": true,
  "message": "success",
  "result": {
    "transform": [
      "horrible_zombie",
      "halloween_makeup",
      "dark_gothic",
      "halloween_dark_makeup",
      "japanese_horror",
      "synthwave_punk",
      "chocolate_man",
      "crazy_scientist",
      "dont_starve",
      "white_statue",
      "colorful_illustration",
      "papercut_craft",
      "blood_of_blue",
      "cyber_punk",
      "fanatic_adventure",
      "legend_of_elf",
      "racer",
      "cute_cartoon",
      "super_hero",
      "pixel_art",
      "retro_style",
      "black_swing",
      "fairy_tale",
      "thick_impasto",
      "rainbow_hair",
      "30s_style",
      "water_magic",
      "on_fire",
      "luminous_cloud",
      "pocket_pet",
      "spirited_wind",
      "3d_style",
      "red_redemption",
      "boxing_man",
      "hell_kight",
      "calendar_girl",
      "cute_illustration",
      "aging_filter",
      "realistic_fire",
      "tattoo_magic",
      "christmas_girl",
      "ps_game_style_1",
      "thunderstruck_armor",
      "lightning_punk",
      "aether_punk",
      "new_worlds_pirates",
      "legend_fighters",
      "barbie_girl",
      "cool_guy",
      "muscle_man",
      "blindbox",
      "melted_chocolate",
      "block_world",
      "90s_comic",
      "realistic_thunderstruck_armor",
      "anime_2d",
      "realistic_lightning_punk",
      "white_skin",
      "hourglass_body_shape",
      "pixel_style",
      "anime_hero",
      "christmas_3d",
      "christmas_family",
      "cartoon",
      "80s_style",
      "christmas_cartoon",
      "ps_game_style_2",
      "anime",
      "city_punk",
      "cartoon_tattoo_muscle",
      "pocket_pet",
      "christmas_comic",
      "magic_muscle",
      "super_bowl",
      "romantic_anime",
      "animal_ears",
      "brick_world",
      "skeleton_bride",
      "joker"
    ],
    "expression": [
      "wink",
      "roll_eyes",
      "sad",
      "close_eyes",
      "haha",
      "duck_face",
      "amazing",
      "cool",
      "angry",
      "smile"
    ],
    "age": [
      "child",
      "youth",
      "middle",
      "the_old"
    ],
    "makeup_reference": [
      "https://scdn.lovita.io/makeup/makeup_1.jpg",
      "https://scdn.lovita.io/makeup/makeup_2.jpg",
      "https://scdn.lovita.io/makeup/makeup_3.jpg",
      "https://scdn.lovita.io/makeup/makeup_4.jpg",
      "https://scdn.lovita.io/makeup/makeup_5.jpg",
      "https://scdn.lovita.io/makeup/makeup_6.jpg",
      "https://scdn.lovita.io/makeup/makeup_7.jpg",
      "https://scdn.lovita.io/makeup/makeup_8.jpg",
      "https://scdn.lovita.io/makeup/makeup_9.jpg"
    ]
  }
}
[22/01, 10:28] 𝙷𝚎𝚗𝚛𝚢 𝙰𝚛𝚌𝚊𝚗𝚐𝚎𝚕𝚘: {
  "status": true,
  "message": "success",
  "result": {
    "styles": [
      "animal_fest",
      "old",
      "doll",
      "metal",
      "8bit",
      "city",
      "blazing_torch",
      "clay",
      "realism",
      "simulife",
      "sketch",
      "zombie",
      "oil_stick",
      "balloon",
      "pipe_craft",
      "crystal",
      "felt",
      "jade",
      "pink_girl",
      "vivid",
      "eastern",
      "mythical",
      "ps2",
      "pixel_game",
      "league",
      "lineage",
      "fantasy",
      "gta",
      "persona",
      "happiness",
      "manga",
      "sweet",
      "pixel_art",
      "catwoman",
      "loose",
      "sakura",
      "pocket",
      "grains",
      "graduation",
      "oil_pastel",
      "flora_tour",
      "loong_year",
      "figure",
      "prospera",
      "guardians",
      "expedition",
      "leisure",
      "giftify",
      "amiable",
      "3d_cartoon",
      "sketch_ii",
      "collage",
      "mini_doll",
      "sketchresize",
      "cartoon",
      "fluffy",
      "insta",
      "local_graffiti",
      "peking_opera",
      "opera",
      "torch",
      "sport",
      "dunk",
      "idol",
      "anime25d",
      "anime",
      "comic",
      "manhwa",
      "manhwa_female",
      "manhwa_male",
      "samyang"
    ] different me
  }
}


Request limit reached: As a standard user, your current plan allows up to 3 requests per 1 minute. Consider upgrading your plan to increase your limits.



curl --request POST \
  --url https://api.itsrose.rest/differentMe/create \
  --header 'Authorization: Bearer Rk-3b78f4b1ca5993ae3c727eb07b91f68e' \
  --header 'Content-Type: application/json' \
  --data '{
  "init_image": "https://media.istockphoto.com/id/1388253782/photo/positive-successful-millennial-business-professional-man-head-shot-portrait.jpg?s=612x612&w=0&k=20&c=uS4knmZ88zNA_OjNaE_JCRuq9qn3ycgtHKDKdJSnGdY=",
  "style_id": "torch",
}'


curl --request POST \
  --url https://api.itsrose.rest/turnMe/transform \
  --header 'Authorization: Bearer Rk-3b78f4b1ca5993ae3c727eb07b91f68e' \
  --header 'Content-Type: application/json' \
  --data '{
  "init_image": "https://media.istockphoto.com/id/1388253782/photo/positive-successful-millennial-business-professional-man-head-shot-portrait.jpg?s=612x612&w=0&k=20&c=uS4knmZ88zNA_OjNaE_JCRuq9qn3ycgtHKDKdJSnGdY=",
  "prompt": "",
  "style_id": "city_punk",
  "num_image": 4
}'



*/
import { createCanvas, loadImage } from 'canvas'
import fs from 'fs'

import fetch from "node-fetch"; 
import request from 'request'
import uploadFile from '../lib/uploadFile.js'; 
import uploadImage from '../lib/uploadImage.js'; 
import { unlinkSync, readFileSync, writeFile } from 'fs'; 
import { join } from 'path'; 
const handler = async (m, {args,command,usedPrefix,__dirname,conn,text,isAdmin,isOwner}) => {
  


const filtros = idioma == 'en' ? 
`𝙵̷𝚒̷𝚕̷𝚝̷𝚎̷𝚛̷𝚜̷
`
:
`𝙵̷𝚒̷𝚕̷𝚝̷𝚛̷𝚘̷𝚜̷
♱ 𝙘𝙤𝙢𝙪𝙣𝙞𝙨𝙩𝙖
♱ 𝙘𝙖𝙛𝙚
♱ 𝙙𝙚𝙨𝙚𝙣𝙝𝙤
♱ 𝙩𝙞𝙣𝙩𝙖
♱ 𝙡𝙖𝙥𝙞𝙨
♱ 𝘃𝗼𝗰𝙚
♱ 𝗽𝗿𝗼𝗰𝘂𝗿𝗮𝗱𝗼
♱ 𝗴𝘂𝗻
♱ 𝗴𝗮𝘆
♱ 𝗴𝗿𝗮𝗳𝗶𝘁𝗶
♱ 𝗽𝗮𝗹𝗵𝗮𝗰𝗼
♱ 𝗰𝗼𝗲𝗹𝗵𝗼
`











  async function addObject(imagemSrc, overlaySrc) {
  // Carregar a imagem principal
  const imagem = await loadImage(imagemSrc);
  const canvas = createCanvas(imagem.width, imagem.height);
  const ctx = canvas.getContext('2d');

  // Desenhar a imagem principal no canvas
  ctx.drawImage(imagem, 0, 0, imagem.width, imagem.height);

  // Carregar a imagem do overlay
  const overlay = await loadImage(overlaySrc);

  // Redimensionar o overlay para ser no mínimo 40% menor que a imagem principal
  const overlayScale = 0.6; // 60% do tamanho original
  const overlayWidth = overlay.width * overlayScale;
  const overlayHeight = overlay.height * overlayScale;

  // Calcular a posição do overlay para o canto inferior esquerdo
  const x = 30; // Canto esquerdo
  const y = imagem.height - overlayHeight // Canto inferior

  // Desenhar o overlay redimensionado no canvas
  ctx.drawImage(overlay, x, y, overlayWidth, overlayHeight);

  // Salvar a imagem resultante
  let gunName = getRandom('.png'); 
    let filenameGun = join(__dirname, '../tmp/' + gunName);
  // Salvar a imagem resultante
  const out = fs.createWriteStream(filenameGun);
  const stream = canvas.createPNGStream();
  stream.pipe(out);
  out.on('finish', () =>
  {
    console.log('A imagem foi salva com sucesso.')
    
    
  fs.readFile(filenameGun, (err, data) => {
    if (err) throw err;
    
    // Envia o arquivo como um buffer
    conn.sendFile(m.chat, data, 'image.png', '', m);
  })
})
 
}
  async function addOverlay(imagemBaseSrc, imagemTopoSrc,opacidade) {

const imagemBase = await loadImage(imagemBaseSrc);
  const imagemTopo = await loadImage(imagemTopoSrc);
  
  // O canvas terá o tamanho da imagem base
  const canvas = createCanvas(imagemBase.width, imagemBase.height);
  const ctx = canvas.getContext('2d');
  
  // Desenhar a imagem base no canvas
  ctx.drawImage(imagemBase, 0, 0);
  
  // Definir a opacidade para a imagem do topo
  ctx.globalAlpha = opacidade;
  
  // Desenhar a imagem do topo no canvas
  ctx.drawImage(imagemTopo, 0, 0, imagemBase.width, imagemBase.height);
  
  // Salvar a imagem resultante
  let gunName = getRandom('.png'); 
    let filenameGun = join(__dirname, '../tmp/' + gunName);
  // Salvar a imagem resultante
  const out = fs.createWriteStream(filenameGun);
  const stream = canvas.createPNGStream();
  stream.pipe(out);
  out.on('finish', () =>
  {
    console.log('A imagem foi salva com sucesso.')
    
    
  fs.readFile(filenameGun, (err, data) => {
    if (err) throw err;
    
    // Envia o arquivo como um buffer
    conn.sendFile(m.chat, data, 'image.png', '', m);
  })
})
 
}
  async function addProcurado(templateSrc, text1, text2, personImageSrc) {
  const template = await loadImage(templateSrc);
  const personImage = await loadImage(personImageSrc);
  
  // O canvas terá o tamanho da imagem de modelo mais espaço para o texto
  const canvasHeight = template.height // 60 pixels para o texto
  const canvas = createCanvas(template.width, canvasHeight);
  const ctx = canvas.getContext('2d');
  
  // Desenhar a imagem de modelo no canvas
  ctx.drawImage(template, 0, 0);
  
  // Configurações para o texto
  let fontSize = 25
 
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.font = `bold ${fontSize}px Arial`; 
  // Desenhar text1 no topo do modelo
  ctx.fillText(text1, template.width / 2, 107.5);

ctx.textBaseline = 'top'; // Alinhar texto pelo topo
/*
function adjustAndWrapText(ctx, text, maxWidth, fontSize) {
  let lines = [];
  let lineHeight = fontSize * 0.7; // Altura da linha baseada no tamanho da fonte

  do {
   lines = [];
    let currentLine = '';
    let words = text.split(' ');
fontSize -= 4;
    words.forEach(word => {
      let testLine = currentLine + word + ' ';
      let metrics = ctx.measureText(testLine);
      let testWidth = metrics.width;

      // Ajuste aqui: use um valor mais próximo de maxWidth para permitir linhas mais longas
      if (testWidth > maxWidth * 1.4 && currentLine !== '') {
        lines.push(currentLine);
        currentLine = word + ' ';
      } else {
        currentLine = testLine;
      }
    });

    lines.push(currentLine); // Adicionar a última linha

    // Reduzir o tamanho da fonte se alguma linha for maior que a largura máxima
    if (lines.some(line => ctx.measureText(line).width > maxWidth * 1.4)) {
      fontSize -= 2;
      lineHeight = fontSize * 0.6;
    }
    
  } while (lines.some(line => ctx.measureText(line).width > maxWidth * 1.4) && fontSize > 10);
  return { lines, lineHeight, fontSize };
}

// Exemplo de uso:
if (ctx.measureText(text2).width > template.width * 0.9) {
  let fontSmall = 20; // Defina o tamanho inicial da fonte
  const { lines, lineHeight, fontSize: adjustedFontSize } = adjustAndWrapText(ctx, text2.toUpperCase(), template.width, fontSmall);
  console.log("fonte tamanho:" + adjustedFontSize);
  ctx.font = `bold ${adjustedFontSize}px Arial`;
  lines.forEach((line, index) => {
    ctx.fillText(line, template.width / 2, 125 + index * lineHeight - (template.height*0.02));
  });
  
  
  */
 
  console.log(ctx.measureText(text2).width)
  if (ctx.measureText(text2).width > 420) {
  function adjustTextSizeAndWrap(ctx, text, maxWidth, maxHeight, initialFontSize) {
  let fontSize = initialFontSize;
  let lineHeight = fontSize * 1.2;
  let lines = [];
  let textHeight;

  do {
    lines = wrapText(ctx, text, maxWidth, fontSize);
    textHeight = lines.length * lineHeight;

    // Se a altura do texto for maior que a altura máxima, reduza o tamanho da fonte
    if (textHeight > maxHeight) {
      fontSize -= 2;
      lineHeight = fontSize * 0.9;
    }
  } while ((textHeight > maxHeight || lines.some(line => ctx.measureText(line).width > maxWidth)) && fontSize > 10);

  return { lines, lineHeight, fontSize };
}

function wrapText(ctx, text, maxWidth, fontSize) {
  ctx.font = `bold ${fontSize}px Arial`;
  let lines = [];
  let words = text.split(' ');
  let currentLine = '';

  words.forEach(word => {
    let testLine = currentLine + word + ' ';
    let metrics = ctx.measureText(testLine);
    let testWidth = metrics.width;

    if (testWidth > maxWidth && currentLine !== '') {
      lines.push(currentLine);
      currentLine = word + ' ';
    } else {
      currentLine = testLine;
    }
  });

  lines.push(currentLine); // Adicionar a última linha
  return lines;
}

// Exemplo de uso:
let initialFontSize = 20; // Tamanho inicial da fonte
let maxHeight = 30; // Altura máxima para o texto
const { lines, lineHeight, fontSize: adjustedFontSize } = adjustTextSizeAndWrap(ctx, text2.toUpperCase(), template.width, maxHeight, initialFontSize);

ctx.font = `bold ${adjustedFontSize}px Arial`;
lines.forEach((line, index) => {
  ctx.fillText(line, template.width / 2, 115 + index * lineHeight);
});

}


else {
  ctx.font = `bold ${fontSize}px Arial`; 
  ctx.fillText(text2.toUpperCase(), template.width - (template.width * 0.5), 125);
}

  // Desenhar a imagem da pessoa abaixo de TEXT2
 ctx.drawImage(personImage, 145, 160, 225, 225)
  // Salvar a imagem resultante
  
  let gunName = getRandom('.png'); 
    let filenameGun = join(__dirname, '../tmp/' + gunName);
  // Salvar a imagem resultante
  const out = fs.createWriteStream(filenameGun);
  const stream = canvas.createPNGStream();
  stream.pipe(out);
  out.on('finish', () =>
  {
    console.log('A imagem foi salva com sucesso.')
    
    
  fs.readFile(filenameGun, (err, data) => {
    if (err) throw err;
    
    // Envia o arquivo como um buffer
    conn.sendFile(m.chat, data, 'image.png', '', m);
  })
})
 
}


async function addCigarro(imagemSrc, textoBase) {
  // Carregar a imagem principal
  const imagem = await loadImage(imagemSrc); 
  const canvas = createCanvas(1400,2000);
  const ctx = canvas.getContext('2d');
  
  
  
  ctx.fillStyle = 'yellow';
  
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.font = `bold 225px "Arial Rounded MT Bold"`; // Fonte redonda e em negrito
  ctx.textAlign = 'center';
  
  
  ctx.fillStyle = 'black';
  let textoCigarro = idioma == 'en' ? 'VOCÊ' : 'YOU'
  ctx.fillText(textoCigarro, canvas.width/2, 187.5);

  let fontSize = 200 // Tamanho de fonte inicial
  let lineHeight = fontSize * 1.2; // Altura da linha baseada no tamanho da fonte
  ctx.font = `bold ${fontSize}px "Arial Rounded MT Bold"`;
  ctx.textAlign = 'center';
  ctx.fillStyle = 'black';
ctx.drawImage(imagem,canvas.width*0.0005,canvas.height*0.12,canvas.width, canvas.height*0.7)
console.log(ctx.measureText(textoBase).width)
console.log(canvas.width)
  if (ctx.measureText(textoBase).width > canvas.width * 0.6 ) {
  function adjustTextSizeAndWrap(ctx, text, maxWidth, maxHeight, initialFontSize) {
  let fontSize = initialFontSize;
  let lineHeight = fontSize * 2.35;
  let lines = [];
  let textHeight;

  do {
    fontSize -= 1;
    lines = wrapText(ctx, text, maxWidth, fontSize);
    textHeight = lines.length * lineHeight;

    // Se a altura do texto for maior que a altura máxima, reduza o tamanho da fonte
    if (textHeight > maxHeight) {
      
      
      lineHeight = fontSize * 0.84
    }
  } while ((textHeight > maxHeight || lines.some(line => ctx.measureText(line).width > maxWidth)) && fontSize > 10);

  return { lines, lineHeight, fontSize };
}

function wrapText(ctx, text, maxWidth, fontSize) {
  ctx.font = `bold ${fontSize}px Arial`;
  let lines = [];
  let words = text.split(' ');
  let currentLine = '';

  words.forEach(word => {
    let testLine = currentLine + word + ' ';
    let metrics = ctx.measureText(testLine);
    let testWidth = metrics.width;

    if (testWidth > maxWidth && currentLine !== '') {
      lines.push(currentLine);
      currentLine = word + ' ';
    } else {
      currentLine = testLine;
    }
  });

  lines.push(currentLine); // Adicionar a última linha
  return lines;
}

// Exemplo de uso:
 // Tamanho inicial da fonte
let nnt = 200
let maxHeight =109; // Altura máxima para o texto
const { lines, lineHeight, fontSize: adjustedFontSize } = adjustTextSizeAndWrap(ctx, textoBase.toUpperCase(), canvas.width, maxHeight, nnt);

ctx.font = `bold ${adjustedFontSize}px Arial`;
lines.forEach((line, index) => {
  ctx.fillText(line, canvas.width / 2,-125+ canvas.height  + index * lineHeight -60);
});

}


else {
  ctx.font = `bold 215px Arial`; 
  
  ctx.fillText(textoBase.toUpperCase(), canvas.width/2, canvas.height -75);
}

  
  // Desenha cada linha de texto no canvas
  
 
  
  
  

    
  let imgov = getRandom('.png'); 
    let nameov = join(__dirname, '../tmp/' + imgov);
  // Salvar a imagem resultante
  const oout = fs.createWriteStream(nameov);
  const stream = canvas.createPNGStream();
  stream.pipe(oout);
  oout.on('finish', () =>
  {
    console.log('A imagem foi salva com sucesso.')
    
    
  fs.readFile(nameov, (err, data) => {
    if (err) throw err;
    
    // Envia o arquivo como um buffer
    conn.sendFile(m.chat, data, 'image.png', '', m);
  })
})
  
}

  if(!(isAdmin || isOwner) && global.db.data.chats[m.chat].midia===false){
   m.react("❌")
   
   return !0;
 } 
 
let estiloPrompt = ''
if(args[1]){

  estiloPrompt = args.slice(1).join(' ')
  console.log(estiloPrompt)
}
      
  const who = m.quoted ? m.quoted.sender : m.mentionedJid && m.mentionedJid[0] ? m.mentionedJid[0] : m.fromMe ? conn.user.jid : m.sender;
 let user = a => '@' + a.split('@')[0] //'@' + 
 const q = m.quoted ? m.quoted : m;
  
 
  const mime = (q.msg || q).mimetype || q.mediaType || '';
  let isTele = /image\/(png|jpe?g|gif)|video\/mp4/.test(mime);
  
  if(args[0]=='gun' || command =='gun'){
    let ovv = join(__dirname, '../media/overlays/gun.png');
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);

try {
addObject(images,ovv)


} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    

    
    let img = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
    addObject(img,ovv)
    
  
  
  }
  
    
    return 
  }
  if(args[0]=='comunista' || command =='comunista'){
    let ovv = join(__dirname, '../media/overlays/comunista.jpg');
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);

try {
addOverlay(images,ovv,0.4)


} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    

    
    let img = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
    addOverlay(img,ovv,0.4)
    
  
  
  }
  
    
    return 
  }
  if(args[0]=='you' || command =='you' || args[0]=='voce' || command =='voce' || args[0]=='você' || command =='você'){
    if(command=='voce' || command=='você' || command=='you'){
      if(!text){
                return m.reply(`┌──[ BYΓΞSΞC ]─[~] 
└─ $ ./effects.c
> ‎ 
> ${idioma == 'en' ? "𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚢𝚘𝚞 𝚐𝚘𝚝𝚝𝚊 𝚙𝚛𝚘𝚟𝚒𝚍𝚎 𝚖𝚘𝚛𝚎 𝚒𝚗𝚏𝚘 𝚏𝚘𝚛 𝚖𝚎! 𝙲𝚑𝚎𝚌𝚔 𝚝𝚑𝚎 𝚎𝚡𝚊𝚖𝚙𝚕𝚎" : "𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚟𝚘𝚌𝚎 𝚝𝚎𝚖 𝚚𝚞𝚎 𝚖𝚎 𝚙𝚊𝚜𝚜𝚊𝚛 𝚖𝚊𝚒𝚜 𝚒𝚗𝚏𝚘𝚛𝚖𝚊𝚌𝚘𝚎𝚜! 𝙾𝚕𝚑𝚊 𝚘 𝚎𝚡𝚎𝚖𝚙𝚕𝚘 𝚊𝚒:"}
> ‎ 
${usedPrefix + command} ${idioma == 'en' ? "turn emo " : "vira emo"}
`)
      }if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);

try {
addCigarro(images,text)


} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    

    
    let img = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
    addCigarro(img,text)
    
  
  
  }
    }
    else if(args[0]=='voce' || args[0]=='você' || args[0] == 'you')
    {
      m.react("🕰️")
      if(!args.slice(1).join(' ')){
        return m.reply(`┌──[ BYΓΞSΞC ]─[~] 
└─ $ ./effects.c
> ‎ 
> ${idioma == 'en' ? "𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚢𝚘𝚞 𝚐𝚘𝚝𝚝𝚊 𝚙𝚛𝚘𝚟𝚒𝚍𝚎 𝚖𝚘𝚛𝚎 𝚒𝚗𝚏𝚘 𝚏𝚘𝚛 𝚖𝚎! 𝙲𝚑𝚎𝚌𝚔 𝚝𝚑𝚎 𝚎𝚡𝚊𝚖𝚙𝚕𝚎" : "𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚟𝚘𝚌𝚎 𝚝𝚎𝚖 𝚚𝚞𝚎 𝚖𝚎 𝚙𝚊𝚜𝚜𝚊𝚛 𝚖𝚊𝚒𝚜 𝚒𝚗𝚏𝚘𝚛𝚖𝚊𝚌𝚘𝚎𝚜! 𝙾𝚕𝚑𝚊 𝚘 𝚎𝚡𝚎𝚖𝚙𝚕𝚘 𝚊𝚒:"}
> ‎ 
${usedPrefix + args[0]} ${idioma == 'en' ? "turn emo " : "vira emo"}
`)
      }
      if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);

try {
addCigarro(images,args.splice(1).join(' '))


} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    

    
    let img = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
    addCigarro(img,args.splice(1).join(' '))
    
  
  
  }
  
  
  
  
  
  
    }
   
    return 
  }

  if(args[0]=='procurado' || command =='procurado' || args[0]=='wanted' || command =='wanted'){
    let modep = idioma == 'en' ? join(__dirname, '../media/overlays/wanted.jpg') : join(__dirname, '../media/overlays/procurado.jpg');
    
    
    
    if(command=='procurado'){
      if(!text){
                return m.reply(`┌──[ BYΓΞSΞC ]─[~] 
└─ $ ./effects.c
> ‎ 
> ${idioma == 'en' ? "𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚢𝚘𝚞 𝚐𝚘𝚝𝚝𝚊 𝚙𝚛𝚘𝚟𝚒𝚍𝚎 𝚖𝚘𝚛𝚎 𝚒𝚗𝚏𝚘 𝚏𝚘𝚛 𝚖𝚎! 𝙲𝚑𝚎𝚌𝚔 𝚝𝚑𝚎 𝚎𝚡𝚊𝚖𝚙𝚕𝚎" : "𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚟𝚘𝚌𝚎 𝚝𝚎𝚖 𝚚𝚞𝚎 𝚖𝚎 𝚙𝚊𝚜𝚜𝚊𝚛 𝚖𝚊𝚒𝚜 𝚒𝚗𝚏𝚘𝚛𝚖𝚊𝚌𝚘𝚎𝚜! 𝙾𝚕𝚑𝚊 𝚘 𝚎𝚡𝚎𝚖𝚙𝚕𝚘 𝚊𝚒:"}
> ‎ 
${usedPrefix + command} ${idioma == 'en' ? "Accused of cyber fraud" : "Acusado de fraude fiscal"}
`)
      }if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);

try {
addProcurado(images,text)


} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    

    
    let img = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
    addProcurado(img,text)
    
  
  
  }
    }
    else if(args[0]=='procurado')
    {
      m.react("🕰️")
      if(!args.slice(1).join(' ')){
        return m.reply(`┌──[ BYΓΞSΞC ]─[~] 
└─ $ ./effects.c
> ‎ 
> ${idioma == 'en' ? "𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚢𝚘𝚞 𝚐𝚘𝚝𝚝𝚊 𝚙𝚛𝚘𝚟𝚒𝚍𝚎 𝚖𝚘𝚛𝚎 𝚒𝚗𝚏𝚘 𝚏𝚘𝚛 𝚖𝚎! 𝙲𝚑𝚎𝚌𝚔 𝚝𝚑𝚎 𝚎𝚡𝚊𝚖𝚙𝚕𝚎" : "𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚟𝚘𝚌𝚎 𝚝𝚎𝚖 𝚚𝚞𝚎 𝚖𝚎 𝚙𝚊𝚜𝚜𝚊𝚛 𝚖𝚊𝚒𝚜 𝚒𝚗𝚏𝚘𝚛𝚖𝚊𝚌𝚘𝚎𝚜! 𝙾𝚕𝚑𝚊 𝚘 𝚎𝚡𝚎𝚖𝚙𝚕𝚘 𝚊𝚒:"}
> ‎ 
${usedPrefix + args[0]} ${idioma == 'en' ? "Accused of cyber fraud" : "Acusado de fraude fiscal"} 
`)
      }
      if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);

try {
addProcurado(modep,global.db.data.users[who].name,args.splice(1).join(' '),images)


} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    

    
    let img = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
    addProcurado(modep,global.db.data.users[who].name,args.splice(1).join(' '),img)
  
  
  }
  
  
  
  
  
  
    }
   
    return 
  }




  if (['desenho', 'drawing', 'sketch'].includes(args[0]) || ['desenho', 'drawing', 'sketch'].includes(command)) {
    // Your logic here

    if (/image/g.test(mime)){
   
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=caricature&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'caricature',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }










  if (['velho', 'idoso', 'old'].includes(args[0]) || ['velho', 'idoso', 'old'].includes(command)) {
    // Your logic here
    async function fetchImageUrl(initImage) {
      const response = await fetch('https://api.itsrose.rest/turnMe/age', {
          method: 'POST',
          headers: {
              'Authorization': `Bearer ${global.itsrose}`,
              'Content-Type': 'application/json'
          },
          body: JSON.stringify({
              init_image: initImage,
              age: "the_old"
          })
      });
  
      if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
      }
  
      const data = await response.json();
      return data.result.images[0]; // Return the first image URL
  }
  

    if (/image/g.test(mime)){
   
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {

    fetchImageUrl(images)
        .then(imageUrl => {
    console.log('Image URL:', imageUrl) 

    await conn.sendFile(m.chat, imageUrl, 'error.jpg', null, m);

         })
        .catch(err => {
          sendSystemErrorAlert(global.db.data.chats[m.chat].language || "en");
          
          console.error('Error fetching image URL:', err)
});
  
      
        

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
let imagemn = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    fetchImageUrl(imagemn)
    .then(imageUrl => {
console.log('Image URL:', imageUrl) 

await conn.sendFile(m.chat, imageUrl, 'error.jpg', null, m);

     })
    .catch(err => {
      sendSystemErrorAlert(global.db.data.chats[m.chat].language || "en");
      
      console.error('Error fetching image URL:', err)
});


   
  
  }
  
    
    return 
  }
  if(args[0]=='grafiti'){
    if (/image/g.test(mime)){
   
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=staco&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'staco',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  if(['rabbit', 'coelho', 'coeio'].includes(args[0]) || ['rabbit', 'coelho', 'coeio'].includes(command)){
    if (/image/g.test(mime)){
   
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=bunny&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'bunny',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  if(['clown', 'palhaço', 'palhaco'].includes(args[0]) || ['clown', 'palhaço', 'palhaco'].includes(command)){
    if (/image/g.test(mime)){
   
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=clown&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'clown',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  if(args[0]=='gay' || command=='gay'){
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://itzpire.site/maker/rainbow?url=${images}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://itzpire.site', '/maker/rainbow', {

    url: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  
  if(['tinta', 'ink', 'pintura'].includes(args[0]) || ['tinta', 'ink', 'pintura'].includes(command)){
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=ink&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'ink',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  if(['coffee', 'café', 'cafe'].includes(args[0]) || ['coffee', 'café', 'cafe'].includes(command)){
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=latte&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'latte',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  if(['lápis', 'lapis', 'pencil'].includes(args[0]) || ['lápis', 'coelho', 'coeio'].includes(command)){
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  const rslt = `https://api.neoxr.eu/api/effect?style=sketch&image=${images}&apikey=${global.neoxr}`

await conn.sendFile(m.chat, rslt, 'error.jpg', null, m);

} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.neoxr.eu', '/api/effect', {
    apikey: global.neoxr,
    style: 'sketch',
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
    
  conn.sendFile(m.chat, dawta,``,);
  console.log(who)
  
  }
  
    
    return 
  }
  
  if(['commie', 'comunista', 'communism','soviet'].includes(args[0]) || ['commie', 'comunista', 'communism','soviet'].includes(command)){
    
    if (/image/g.test(mime)){
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  
const anime = `https://api.popcat.xyz/communism?image=${images}`;


await conn.sendFile(m.chat, dawta,'')
} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    
  let dawta = global.API('https://api.popcat.xyz', '/communism', {
    
    image: await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png') })
    
    console.log(dawta)
      conn.sendFile(m.chat, dawta,'')
  console.log(who)
  
  }
    
    return 
  }
  
  
  if (/image/g.test(mime)){
     
 let styleMappings = {
  "horrible_zombie": "horrible.zombie",
    "halloween_makeup": "halloween.makeup",
    "dark_gothic": "dark.gothic",
    "halloween_dark_makeup": "halloween.dark.makeup",
    "japanese_horror": "japanese.horror",
    "synthwave_punk": "synthwave.punk",
    "chocolate_man": "chocolate.man",
    "crazy_scientist": "crazy.scientist",
    "dont_starve": "dont.starve",
    "white_statue": "white.statue",
    "colorful_illustration": "colorful.illustration",
    "papercut_craft": "papercut.craft",
    "blood_of_blue": "blood.of.blue",
    "cyber_punk": "cyber.punk",
    "fanatic_adventure": "fanatic.adventure",
    "legend_of_elf": "legend.of.elf",
    "racer": "racer",
    "cute_cartoon": "cute.cartoon",
    "super_hero": "super.hero",
    "pixel_art": "pixel.art",
    "retro_style": "retro.style",
    "black_swing": "black.swing",
    "fairy_tale": "fairy.tale",
    "thick_impasto": "thick.impasto",
    "rainbow_hair": "rainbow.hair",
    "30s_style": "30s.style",
    "water_magic": "water.magic",
    "on_fire": "on.fire",
    "luminous_cloud": "luminous.cloud",
    "pocket_pet": "pocket.pet",
    "spirited_wind": "spirited.wind",
    "3d_style": "3d.style",
    "red_redemption": "red.redemption",
    "boxing_man": "boxing.man",
    "hell_kight": "hell.kight",
    "calendar_girl": "calendar.girl",
    "cute_illustration": "cute.illustration",
    "aging_filter": "aging.filter",
    "realistic_fire": "realistic.fire",
    "tattoo_magic": "tattoo.magic",
    "christmas_girl": "christmas.girl",
    "ps_game_style_1": "ps.game.style.1",
    "thunderstruck_armor": "thunderstruck.armor",
    "lightning_punk": "lightning.punk",
    "aether_punk": "aether.punk",
    "new_worlds_pirates": "new.worlds.pirates",
    "legend_fighters": "legend.fighters",
    "barbie_girl": "barbie.girl",
    "cool_guy": "cool.guy",
    "muscle_man": "muscle.man",
    "blindbox": "blindbox",
    "melted_chocolate": "melted.chocolate",
    "block_world": "block.world",
    "90s_comic": "90s.comic",
    "realistic_thunderstruck_armor": "realistic.thunderstruck.armor",
    "anime_2d": "anime.2d",
    "realistic_lightning_punk": "realistic.lightning.punk",
    "white_skin": "white.skin",
    "hourglass_body_shape": "hourglass.body.shape",
    "pixel_style": "pixel.style",
    "anime_hero": "anime.hero",
    "christmas_3d": "christmas.3d",
    "christmas_family": "christmas.family",
    "cartoon": "cartoon",
    "80s_style": "80s.style",
    "christmas_cartoon": "christmas.cartoon",
    "ps_game_style_2": "ps.game.style.2",
    "anime": "anime",
    "city_punk": "city.punk",
    "cartoon_tattoo_muscle": "cartoon.tattoo.muscle",
    "pocket_pet": "pocket.pet",
    "christmas_comic": "christmas.comic",
    "magic_muscle": "magic.muscle",
    "super_bowl": "super.bowl",
    "romantic_anime": "romantic.anime",
    "animal_ears": "animal.ears",
    "brick_world": "brick.world",
    "skeleton_bride": "skeleton.bride",
    "joker": "joker",
  "zombie": "zombie",
  "palhaco": "palhaco",
  "coelho":"coelho",
  "grafiti":"grafiti"
};
    let styleId = styleMappings[args[0]];
console.log(styleId)

    if(args[0]=='gta'){
      const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  
 
const requestBody = {
  init_image: images,
  style_id: 'gta',
  color: "default"

};

const apiUrl = 'https://api.itsrose.rest/image/_inference_style';
const authToken = itsrose;

let response = await fetch(apiUrl, {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Authorization': authToken,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(requestBody),
})
  .then(response =>{
    console.log(response)
    
return   response.json()})
    .then(data => {
      console.log(data)
  
       conn.sendFile(m.chat, data.result.images[0], 'error.jpg', null, m);
        
    
 
    })
  
  
  .catch(error => console.error('Error:', error));
    
    



} 
catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

    
      
      return 
    }
   
   
 else if(!args[0]){
   m.reply(`─┅──┅❖ ༒︎ ❖─┅──┅ 
   𝑪𝒐𝒎𝒂𝒏𝒅𝒐 𝒊𝒏𝒗𝒂𝒍𝒊𝒅𝒐. ❌👁️
   𝑷𝒂𝒓𝒂 𝒖𝒔𝒂𝒓 𝒐𝒔 𝒆𝒇𝒆𝒊𝒕𝒐𝒔..
   𝒖𝒔𝒆 .𝒆𝒇𝒆𝒊𝒕𝒐 [𝒆𝒇𝒆𝒊𝒕𝒐]
   

𝙴𝚏𝚎𝚒𝚝𝚘𝚜 𝙸𝙰
┎┈┈┈┈┈┈┈┈┈┈
> ʜᴏʀʀɪʙʟᴇ.ᴢᴏᴍʙɪᴇ
> ʜᴀʟʟᴏᴡᴇᴇɴ.ᴍᴀᴋᴇᴜᴘ
> ᴅᴀʀᴋ.ɢᴏᴛʜɪᴄ
> ʜᴀʟʟᴏᴡᴇᴇɴ.ᴅᴀʀᴋ.ᴍᴀᴋᴇᴜᴘ 
> ᴊᴀᴘᴀɴᴇꜱᴇ.ʜᴏʀʀᴏʀ 
> ꜱʏɴᴛʜᴡᴀᴠᴇ.ᴘᴜɴᴋ
> ᴄʜᴏᴄᴏʟᴀᴛᴇ.ᴍᴀɴ 
> ᴄʀᴀᴢʏ.ꜱᴄɪᴇɴᴛɪꜱᴛ 
> ᴅᴏɴᴛ.ꜱᴛᴀʀᴠᴇ
> ᴡʜɪᴛᴇ.ꜱᴛᴀᴛᴜᴇ
> ᴄᴏʟᴏʀꜰᴜʟ.ɪʟʟᴜꜱᴛʀᴀᴛɪᴏɴ 
> ᴘᴀᴘᴇʀᴄᴜᴛ.ᴄʀᴀꜰᴛ
> ʙʟᴏᴏᴅ.ᴏꜰ.ʙʟᴜᴇ
> ᴄʏʙᴇʀ.ᴘᴜɴᴋ 
> ꜰᴀɴᴀᴛɪᴄ.ᴀᴅᴠᴇɴᴛᴜʀᴇ
> ʟᴇɢᴇɴᴅ.ᴏꜰ.ᴇʟꜰ
> ʀᴀᴄᴇʀ 
> ᴄᴜᴛᴇ.ᴄᴀʀᴛᴏᴏɴ 
> ꜱᴜᴘᴇʀ.ʜᴇʀᴏ
> ᴘɪxᴇʟ.ᴀʀᴛ
> ʀᴇᴛʀᴏ.ꜱᴛʏʟᴇ
> ʙʟᴀᴄᴋ.ꜱᴡɪɴɢ
> ꜰᴀɪʀʏ.ᴛᴀʟᴇ 
> ᴛʜɪᴄᴋ.ɪᴍᴘᴀꜱᴛᴏ 
> ʀᴀɪɴʙᴏᴡ.ʜᴀɪʀ
> 30ꜱ.ꜱᴛʏʟᴇ 
> ᴡᴀᴛᴇʀ.ᴍᴀɢɪᴄ 
> ᴏɴ.ꜰɪʀᴇ 
> ʟᴜᴍɪɴᴏᴜꜱ.ᴄʟᴏᴜᴅ 
> ᴘᴏᴄᴋᴇᴛ.ᴘᴇᴛ 
> ꜱᴘɪʀɪᴛᴇᴅ.ᴡɪɴᴅ 
> 3ᴅ.ꜱᴛʏʟᴇ
> ʀᴇᴅ.ʀᴇᴅᴇᴍᴘᴛɪᴏɴ 
> ʙᴏxɪɴɢ.ᴍᴀɴ
> ʜᴇʟʟ.ᴋɪɢʜᴛ
> ᴄᴀʟᴇɴᴅᴀʀ.ɢɪʀʟ
> ᴄᴜᴛᴇ.ɪʟʟᴜꜱᴛʀᴀᴛɪᴏɴ
> ᴀɢɪɴɢ.ꜰɪʟᴛᴇʀ 
> ʀᴇᴀʟɪꜱᴛɪᴄ.ꜰɪʀᴇ
> ᴛᴏᴏ.ᴍᴀɢɪᴄ 
> ᴄʜʀɪꜱᴛᴍᴀꜱ.ɢɪʀʟ
> ᴘꜱ.ɢᴀᴍᴇ.ꜱᴛʏʟᴇ.1 
> ᴛʜᴜɴᴅᴇʀꜱᴛʀᴜᴄᴋ.ᴀʀᴍᴏʀ 
> ʟɪɢʜᴛɴɪɴɢ.ᴘᴜɴᴋ
> ᴀᴇᴛʜᴇʀ.ᴘᴜɴᴋ 
> ɴᴇᴡ.ᴡᴏʀʟᴅꜱ.ᴘɪʀᴀᴛᴇꜱ
> ʟᴇɢᴇɴᴅ.ꜰɪɢʜᴛᴇʀꜱ
> ʙᴀʀʙɪᴇ.ɢɪʀʟ
> ᴄᴏᴏʟ.ɢᴜʏ 
> ᴍᴜꜱᴄʟᴇ.ᴍᴀɴ
> ʙʟɪɴᴅʙᴏx 
> ᴍᴇʟᴛᴇᴅ.ᴄʜᴏᴄᴏʟᴀᴛᴇ
> ʙʟᴏᴄᴋ.ᴡᴏʀʟᴅ 
> 90ꜱ.ᴄᴏᴍɪᴄ 
> ʀᴇᴀʟɪꜱᴛɪᴄ.ᴛʜᴜɴᴅᴇʀꜱᴛʀᴜᴄᴋ.ᴀʀᴍᴏʀ 
> ᴀɴɪᴍᴇ.2ᴅ 
> ʀᴇᴀʟɪꜱᴛɪᴄ.ʟɪɢʜᴛɴɪɴɢ.ᴘᴜɴᴋ
> ᴡʜɪᴛᴇ.ꜱᴋɪɴ 
> ʜᴏᴜʀɢʟᴀꜱꜱ.ʙᴏᴅʏ.ꜱʜᴀᴘᴇ 
> ᴘɪxᴇʟ.ꜱᴛʏʟᴇ 
> ᴀɴɪᴍᴇ.ʜᴇʀᴏ 
> ᴄʜʀɪꜱᴛᴍᴀꜱ.3ᴅ 
> ᴄʜʀɪꜱᴛᴍᴀꜱ.ꜰᴀᴍɪʟʏ
> ᴄᴀʀᴛᴏᴏɴ 80ꜱ.ꜱᴛʏʟᴇ 
> ᴄʜʀɪꜱᴛᴍᴀꜱ.ᴄᴀʀᴛᴏᴏɴ 
> ᴘꜱ.ɢᴀᴍᴇ.ꜱᴛʏʟᴇ.2 
> ᴀɴɪᴍᴇ
> ᴄɪᴛʏ.ᴘᴜɴᴋ 
> ᴄᴀʀᴛᴏᴏɴ.ᴛᴀᴛᴛᴏᴏ.ᴍᴜꜱᴄʟᴇ 
> ᴘᴏᴄᴋᴇᴛ.ᴘᴇᴛ 
> ᴄʜʀɪꜱᴛᴍᴀꜱ.ᴄᴏᴍɪᴄ 
> ᴍᴀɢɪᴄ.ᴍᴜꜱᴄʟᴇ 
> ꜱᴜᴘᴇʀ.ʙᴏᴡʟ 
> ʀᴏᴍᴀɴᴛɪᴄ.ᴀɴɪᴍᴇ 
> ᴀɴɪᴍᴀʟ.ᴇᴀʀꜱ
> ʙʀɪᴄᴋ.ᴡᴏʀʟᴅ 
> ꜱᴋᴇʟᴇᴛᴏɴ.ʙʀɪᴅᴇ
> ᴊᴏᴋᴇʀ
> ________________________
> 
┖┈┈┈┈┈┈┈┈┈┈

𝙵𝚒𝚕𝚝𝚛𝚘𝚜 𝚍𝚎 𝚒𝚖𝚊𝚐𝚎𝚖
♱ 𝙘𝙤𝙢𝙪𝙣𝙞𝙨𝙩𝙖
♱ 𝙘𝙖𝙛𝙚
♱ 𝙙𝙚𝙨𝙚𝙣𝙝𝙤
♱ 𝙩𝙞𝙣𝙩𝙖
♱ 𝙡𝙖𝙥𝙞𝙨
♱ 𝘃𝗼𝗰𝙚
♱ 𝗽𝗿𝗼𝗰𝘂𝗿𝗮𝗱𝗼
♱ 𝗴𝘂𝗻
♱ 𝗴𝗮𝘆
♱ 𝗴𝗿𝗮𝗳𝗶𝘁𝗶
♱ 𝗽𝗮𝗹𝗵𝗮𝗰𝗼
♱ 𝗰𝗼𝗲𝗹𝗵𝗼

─┅──┅❖ ִ𖤐 ❖─┅──┅   `)
return !0
 } //ok


 else if (args[0] && !styleId) {
          m.reply(`─┅──┅❖ ༒︎ ❖─┅──┅ 
   𝑪𝒐𝒎𝒂𝒏𝒅𝒐 𝒊𝒏𝒗𝒂𝒍𝒊𝒅𝒐. ❌👁️
   𝑷𝒂𝒓𝒂 𝒖𝒔𝒂𝒓 𝒐𝒔 𝒆𝒇𝒆𝒊𝒕𝒐𝒔..
   𝒖𝒔𝒆 .𝒆𝒇𝒆𝒊𝒕𝒐 [𝒆𝒇𝒆𝒊𝒕𝒐]
   

𝙴𝚏𝚎𝚒𝚝𝚘𝚜 𝙸𝙰

♱ 𝙖𝙚𝙩𝙝𝙚𝙧
♱ 𝙖𝙞𝙧𝙗𝙚𝙣𝙙𝙚𝙧
♱ 𝙖𝙣𝙞𝙢𝙚
♱ 𝙖𝙫𝙖𝙩𝙖𝙧
♱ 𝙗𝙖𝙗𝙮
♱ 𝙗𝙖𝙧𝙗𝙞𝙚
♱ 𝙗𝙡𝙞𝙣𝙙𝙗𝙤𝙭
♱ 𝙗𝙡𝙤𝙘𝙠
♱ 𝙘𝙝𝙤𝙘𝙤𝙡𝙖𝙩𝙚
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_3𝙙
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙖𝙣𝙞𝙢𝙚
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙘𝙖𝙧𝙩𝙤𝙤𝙣
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙘𝙤𝙢𝙞𝙘
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙥𝙞𝙭𝙚𝙡
♱ 𝙘𝙮𝙗𝙚𝙧𝙥𝙪𝙣𝙠
♱ 𝙙𝙖𝙣𝙞𝙡
𝙗𝙚𝙣𝙙𝙚𝙧
♱ 𝙜𝙝𝙖𝙞𝙧
♱ 𝙜𝙤𝙩𝙝𝙞𝙘
♱ 𝙜𝙩𝙖𝙫
♱ 𝙜𝙩𝙖
♱ 𝙝𝙖𝙡𝙡𝙤𝙬𝙚𝙚𝙣
♱ 𝙝𝙚𝙡𝙡
♱ 𝙝𝙚𝙧𝙤𝙚𝙨
♱ 𝙝𝙤𝙧𝙧𝙤𝙧
♱ 𝙄𝙡𝙡𝙪𝙨𝙩𝙧𝙖𝙩𝙞𝙤𝙣
♱ 𝙞𝙢𝙥𝙖𝙨𝙩𝙤
♱ 𝙟𝙤𝙟𝙤
♱ 𝙟𝙪𝙣𝙚𝙩
♱ 𝙡𝙪𝙢𝙞𝙣𝙤𝙪𝙨
♱ 𝙤𝙡𝙙
♱ 𝙤𝙣𝙚𝙥𝙞𝙚𝙘𝙚
♱ 𝙥𝙖𝙥𝙚𝙧𝙘𝙪𝙩
♱ 𝙥𝙞𝙭𝙚𝙡
♱ 𝙥𝙤𝙠𝙚𝙢𝙤𝙣
♱ 𝙧𝙙𝙧
♱ 𝙧𝙚𝙩𝙧𝙤
♱ 𝙧𝙞𝙘𝙠𝙢𝙤𝙧𝙩𝙮
♱ 𝙨𝙥𝙞𝙧𝙞𝙩𝙚𝙙
♱ 𝙨𝙪𝙧𝙮𝙖
♱ 𝙨𝙮𝙣𝙩𝙝𝙬𝙖𝙫𝙚
♱ 𝙩𝙖𝙩𝙩𝙤𝙤
♱ 𝙩𝙝𝙪𝙣𝙙𝙚𝙧
♱ 𝙬𝙤𝙣𝙠𝙖
♱ 𝙯𝙤𝙢𝙗𝙞𝙚

𝙵𝚒𝚕𝚝𝚛𝚘𝚜 𝚍𝚎 𝚒𝚖𝚊𝚐𝚎𝚖
♱ 𝙘𝙤𝙢𝙪𝙣𝙞𝙨𝙩𝙖
♱ 𝙘𝙖𝙛𝙚
♱ 𝙙𝙚𝙨𝙚𝙣𝙝𝙤
♱ 𝙩𝙞𝙣𝙩𝙖
♱ 𝙡𝙖𝙥𝙞𝙨
♱ 𝘃𝗼𝗰𝙚
♱ 𝗽𝗿𝗼𝗰𝘂𝗿𝗮𝗱𝗼
♱ 𝗴𝘂𝗻
♱ 𝗴𝗮𝘆
♱ 𝗴𝗿𝗮𝗳𝗶𝘁𝗶
♱ 𝗽𝗮𝗹𝗵𝗮𝗰𝗼
♱ 𝗰𝗼𝗲𝗹𝗵𝗼

─┅──┅❖ ִ𖤐 ❖─┅──┅   `)
    } 
    
    
const qs = m.quoted ? m.quoted : m;
const mimee = (qs.msg || qs).mimetype || qs.mediaType || '';

  m.reply(`${idioma == 'en' ? '> [!] 𝙿𝚕𝚎𝚊𝚜𝚎 𝚠𝚊𝚒𝚝. . .' : '> [!] 𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚒𝚖𝚊𝚐𝚎𝚖, 𝚊𝚐𝚞𝚊𝚛𝚍𝚎 . . .' }`);
const datab = await qs.download?.();
const images = await uploadImage(datab);
try {
  
 

let response = await  fetch('https://api.itsrose.rest/image/turnMe', {
  method: 'POST',
  headers: {
    'accept': 'application/json',
    'Authorization': itsrose,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    "init_image": images,
    "style": styleId,
    "skin": "default",
    "image_num": 4,
    "prompt": estiloPrompt,
    "strength": 0.57
  })
})
.then(response => {
    console.log(response)
   return response.json()
  
    })
    .then(data => {
      console.log(data)
      if (data.status && data.result && data.result.images) {
    for (let i = 0; i < data.result.images.length; i++) {
       conn.sendFile(m.chat, data.result.images[i], 'error.jpg', null, m);
        
    }
} else {
    console.error('Invalid data format');
    m.react("⚠️")
}
    })
  
  .catch(error => console.error('Error:', error));
   





} catch (e) {
  console.log(e)
throw `${idioma == 'en' ? "> [!] 𝙷𝚎𝚢 𝚔𝚒𝚍, 𝚝𝚑𝚎𝚛𝚎 𝚠𝚊𝚜 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚒𝚗𝚐 𝚝𝚑𝚎 𝚒𝚖𝚊𝚐𝚎. \n> 𝙲𝚑𝚎𝚌𝚔 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚊 𝚏𝚊𝚌𝚎 𝚒𝚗 𝚒𝚝 𝚏𝚒𝚛𝚜𝚝, 𝚒𝚏 𝚝𝚑𝚎𝚛𝚎'𝚜 𝚜𝚘𝚖𝚎𝚘𝚗𝚎 𝚒𝚗 𝚝𝚑𝚊𝚝 𝚙𝚒𝚌𝚝𝚞𝚛𝚎 𝚊𝚗𝚍 𝚒𝚝'𝚜 𝚐𝚒𝚟𝚒𝚗𝚐 𝚢𝚘𝚞 𝚊𝚗 𝚎𝚛𝚛𝚘𝚛, 𝚜𝚎𝚗𝚍 𝚖𝚎 𝚝𝚑𝚎 𝚕𝚘𝚐 𝚞𝚜𝚒𝚗𝚐 .𝚛𝚎𝚙𝚘𝚛𝚝" : "> [*] 𝙴𝚒 𝚐𝚊𝚛𝚘𝚝𝚘, 𝚑𝚘𝚞𝚟𝚎 𝚞𝚖 𝚎𝚛𝚛𝚘 𝚎𝚖 𝚙𝚛𝚘𝚌𝚎𝚜𝚜𝚊𝚛 𝚊 𝚒𝚖𝚊𝚐𝚎𝚖.\n> 𝚅𝚎𝚛𝚒𝚏𝚒𝚚𝚞𝚎 𝚜𝚎 𝚝𝚎𝚖 𝚊𝚕𝚐𝚞𝚖 𝚛𝚘𝚜𝚝𝚘 𝚗𝚎𝚕𝚊 𝚙𝚛𝚒𝚖𝚎𝚒𝚛𝚘, 𝚜𝚎 𝚝𝚒𝚟𝚎𝚛 𝚊𝚕𝚐𝚞𝚎𝚖 𝚗𝚎𝚜𝚜𝚊 𝚏𝚘𝚝𝚘 𝚎 𝚎𝚜𝚝𝚒𝚟𝚎𝚛 𝚍𝚊𝚗𝚍𝚘 𝚎𝚛𝚛𝚘, 𝚖𝚊𝚗𝚍𝚊 𝚘 𝚕𝚘𝚐 𝚙𝚛𝚊 𝚖𝚒𝚖 𝚞𝚜𝚊𝚗𝚍𝚘 .𝚛𝚎𝚙𝚘𝚛𝚝" }`
}

  
  
  
  }
  if (!/image/g.test(mime)){
    
    let styleMappings = {
  "aether": "aether",
  "airbender": "airbender",
  "anime": "anime",
  "avatar": "avatar",
  "baby": "baby",
  "barbie": "barbie",

  "blindbox": "blindbox",
  "block": "block",
  "chocolate": "chocolate",
  "christmas_3d": "christmas_3d",
  "christmas_anime": "christmas_anime",
  "christmas_cartoon": "christmas_cartoon",
  "christmas_comic": "christmas_comic",
  "christmas_pixar": "christmas_pixar",
  "cyberpunk": "cyberpunk",
  "danil": "danil",
  "firebender": "firebender",
  "ghair": "ghair",
  "gothic": "gothic",
  "gtav": "gtav",
  "hallowen": "hallowen",
  "hell": "hell",
  "heroes": "heroes",
  "horror": "horror",
  "illustration": "illustration",
  "impasto": "impasto",
  "jojo": "jojo",
  "junet": "junet",

  "luminous": "luminous",
  "old": "old",
  "onepiece": "onepiece",
  "papercut": "papercut",

  "pixar": "pixar",
  "pixar_2": "pixar_2",
  "pixel": "pixel",
  "pokemon": "pokemon",
  "rdr": "rdr",
  "retro": "retro",
  "rickmorty": "rickmorty",
  "spirited": "spirited",

  "surya": "surya",
  "synthwave": "synthwave",
  "tattoo":"tatoo",
  "thunder": "thunder",
  "wonka": "wonka",
  "zombie": "zombie",
    "palhaco": "palhaco",
  "coelho":"coelho",
  "grafiti":"grafiti"
};
    let styleId = styleMappings[args[0]];
console.log(styleId)



 if(args[0]=='gta'){
      let profile = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
  


const requestBody = {
  init_image: profile,
  style_id: 'gta',
};

const apiUrl = 'https://api.itsrose.rest/image/_inference_style';
const authToken = itsrose;

let response = await fetch(apiUrl, {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Authorization': authToken,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(requestBody),
})
  .then(response => {
    console.log(response)
   return response.json()
    })
  .then(data => {console.log(data)
  console.log(data.result.images)
   conn.sendFile(m.chat, data.result.images[0],'error.jpg',null,m)
  }
  )
  .catch(error => console.error('Error:', error));
    
    
    
     return 
    
    }
 
  else if(!args[0]){
   m.reply(`─┅──┅❖ ༒︎ ❖─┅──┅ 
   𝑪𝒐𝒎𝒂𝒏𝒅𝒐 𝒊𝒏𝒗𝒂𝒍𝒊𝒅𝒐. ❌👁️
   𝑷𝒂𝒓𝒂 𝒖𝒔𝒂𝒓 𝒐𝒔 𝒆𝒇𝒆𝒊𝒕𝒐𝒔..
   𝒖𝒔𝒆 .𝒆𝒇𝒆𝒊𝒕𝒐 [𝒆𝒇𝒆𝒊𝒕𝒐]
   

𝙴𝚏𝚎𝚒𝚝𝚘𝚜 𝙸𝙰

♱ 𝙖𝙚𝙩𝙝𝙚𝙧
♱ 𝙖𝙞𝙧𝙗𝙚𝙣𝙙𝙚𝙧
♱ 𝙖𝙣𝙞𝙢𝙚
♱ 𝙖𝙫𝙖𝙩𝙖𝙧
♱ 𝙗𝙖𝙗𝙮
♱ 𝙗𝙖𝙧𝙗𝙞𝙚
♱ 𝙗𝙡𝙞𝙣𝙙𝙗𝙤𝙭
♱ 𝙗𝙡𝙤𝙘𝙠
♱ 𝙘𝙝𝙤𝙘𝙤𝙡𝙖𝙩𝙚
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_3𝙙
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙖𝙣𝙞𝙢𝙚
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙘𝙖𝙧𝙩𝙤𝙤𝙣
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙘𝙤𝙢𝙞𝙘
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙥𝙞𝙭𝙚𝙡
♱ 𝙘𝙮𝙗𝙚𝙧𝙥𝙪𝙣𝙠
♱ 𝙙𝙖𝙣𝙞𝙡
𝙗𝙚𝙣𝙙𝙚𝙧
♱ 𝙜𝙝𝙖𝙞𝙧
♱ 𝙜𝙤𝙩𝙝𝙞𝙘
♱ 𝙜𝙩𝙖𝙫
♱ 𝙜𝙩𝙖
♱ 𝙝𝙖𝙡𝙡𝙤𝙬𝙚𝙚𝙣
♱ 𝙝𝙚𝙡𝙡
♱ 𝙝𝙚𝙧𝙤𝙚𝙨
♱ 𝙝𝙤𝙧𝙧𝙤𝙧
♱ 𝙄𝙡𝙡𝙪𝙨𝙩𝙧𝙖𝙩𝙞𝙤𝙣
♱ 𝙞𝙢𝙥𝙖𝙨𝙩𝙤
♱ 𝙟𝙤𝙟𝙤
♱ 𝙟𝙪𝙣𝙚𝙩
♱ 𝙡𝙪𝙢𝙞𝙣𝙤𝙪𝙨
♱ 𝙤𝙡𝙙
♱ 𝙤𝙣𝙚𝙥𝙞𝙚𝙘𝙚
♱ 𝙥𝙖𝙥𝙚𝙧𝙘𝙪𝙩
♱ 𝙥𝙞𝙭𝙚𝙡
♱ 𝙥𝙤𝙠𝙚𝙢𝙤𝙣
♱ 𝙧𝙙𝙧
♱ 𝙧𝙚𝙩𝙧𝙤
♱ 𝙧𝙞𝙘𝙠𝙢𝙤𝙧𝙩𝙮
♱ 𝙨𝙥𝙞𝙧𝙞𝙩𝙚𝙙
♱ 𝙨𝙪𝙧𝙮𝙖
♱ 𝙨𝙮𝙣𝙩𝙝𝙬𝙖𝙫𝙚
♱ 𝙩𝙖𝙩𝙩𝙤𝙤
♱ 𝙩𝙝𝙪𝙣𝙙𝙚𝙧
♱ 𝙬𝙤𝙣𝙠𝙖
♱ 𝙯𝙤𝙢𝙗𝙞𝙚

𝙵𝚒𝚕𝚝𝚛𝚘𝚜 𝚍𝚎 𝚒𝚖𝚊𝚐𝚎𝚖
♱ 𝙜𝙪𝙣
♱ 𝙘𝙤𝙢𝙪𝙣𝙞𝙨𝙩𝙖
♱ 𝙘𝙖𝙛𝙚
♱ 𝙙𝙚𝙨𝙚𝙣𝙝𝙤
♱ 𝙩𝙞𝙣𝙩𝙖
♱ 𝙡𝙖𝙥𝙞𝙨
♱ 𝘃𝗼𝗰𝙚
♱ 𝗽𝗿𝗼𝗰𝘂𝗿𝗮𝗱𝗼
♱ 𝗴𝗮𝘆
♱ 𝗴𝗿𝗮𝗳𝗶𝘁𝗶
♱ 𝗽𝗮𝗹𝗵𝗮𝗰𝗼
♱ 𝗰𝗼𝗲𝗹𝗵𝗼

─┅──┅❖ ִ𖤐 ❖─┅──┅   `)
return !0
 }
 
 
 else if (args[0] && !styleId) {
             m.reply(`─┅──┅❖ ༒︎ ❖─┅──┅ 
   𝑪𝒐𝒎𝒂𝒏𝒅𝒐 𝒊𝒏𝒗𝒂𝒍𝒊𝒅𝒐. ❌👁️
   𝑷𝒂𝒓𝒂 𝒖𝒔𝒂𝒓 𝒐𝒔 𝒆𝒇𝒆𝒊𝒕𝒐𝒔..
   𝒖𝒔𝒆 .𝒆𝒇𝒆𝒊𝒕𝒐 [𝒆𝒇𝒆𝒊𝒕𝒐]
   

𝙴𝚏𝚎𝚒𝚝𝚘𝚜 𝙸𝙰

♱ 𝙖𝙚𝙩𝙝𝙚𝙧
♱ 𝙖𝙞𝙧𝙗𝙚𝙣𝙙𝙚𝙧
♱ 𝙖𝙣𝙞𝙢𝙚
♱ 𝙖𝙫𝙖𝙩𝙖𝙧
♱ 𝙗𝙖𝙗𝙮
♱ 𝙗𝙖𝙧𝙗𝙞𝙚
♱ 𝙗𝙡𝙞𝙣𝙙𝙗𝙤𝙭
♱ 𝙗𝙡𝙤𝙘𝙠
♱ 𝙘𝙝𝙤𝙘𝙤𝙡𝙖𝙩𝙚
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_3𝙙
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙖𝙣𝙞𝙢𝙚
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙘𝙖𝙧𝙩𝙤𝙤𝙣
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙘𝙤𝙢𝙞𝙘
♱ 𝙘𝙝𝙧𝙞𝙨𝙩𝙢𝙖𝙨_𝙥𝙞𝙭𝙚𝙡
♱ 𝙘𝙮𝙗𝙚𝙧𝙥𝙪𝙣𝙠
♱ 𝙙𝙖𝙣𝙞𝙡
𝙗𝙚𝙣𝙙𝙚𝙧
♱ 𝙜𝙝𝙖𝙞𝙧
♱ 𝙜𝙤𝙩𝙝𝙞𝙘
♱ 𝙜𝙩𝙖𝙫
♱ 𝙜𝙩𝙖
♱ 𝙝𝙖𝙡𝙡𝙤𝙬𝙚𝙚𝙣
♱ 𝙝𝙚𝙡𝙡
♱ 𝙝𝙚𝙧𝙤𝙚𝙨
♱ 𝙝𝙤𝙧𝙧𝙤𝙧
♱ 𝙄𝙡𝙡𝙪𝙨𝙩𝙧𝙖𝙩𝙞𝙤𝙣
♱ 𝙞𝙢𝙥𝙖𝙨𝙩𝙤
♱ 𝙟𝙤𝙟𝙤
♱ 𝙟𝙪𝙣𝙚𝙩
♱ 𝙡𝙪𝙢𝙞𝙣𝙤𝙪𝙨
♱ 𝙤𝙡𝙙
♱ 𝙤𝙣𝙚𝙥𝙞𝙚𝙘𝙚
♱ 𝙥𝙖𝙥𝙚𝙧𝙘𝙪𝙩
♱ 𝙥𝙞𝙭𝙚𝙡
♱ 𝙥𝙤𝙠𝙚𝙢𝙤𝙣
♱ 𝙧𝙙𝙧
♱ 𝙧𝙚𝙩𝙧𝙤
♱ 𝙧𝙞𝙘𝙠𝙢𝙤𝙧𝙩𝙮
♱ 𝙨𝙥𝙞𝙧𝙞𝙩𝙚𝙙
♱ 𝙨𝙪𝙧𝙮𝙖
♱ 𝙨𝙮𝙣𝙩𝙝𝙬𝙖𝙫𝙚
♱ 𝙩𝙖𝙩𝙩𝙤𝙤
♱ 𝙩𝙝𝙪𝙣𝙙𝙚𝙧
♱ 𝙬𝙤𝙣𝙠𝙖
♱ 𝙯𝙤𝙢𝙗𝙞𝙚

𝙵𝚒𝚕𝚝𝚛𝚘𝚜 𝚍𝚎 𝚒𝚖𝚊𝚐𝚎𝚖
♱ 𝙘𝙤𝙢𝙪𝙣𝙞𝙨𝙩𝙖
♱ 𝙘𝙖𝙛𝙚
♱ 𝙩𝙞𝙣𝙩𝙖
♱ 𝙡𝙖𝙥𝙞𝙨
♱ 𝙙𝙚𝙨𝙚𝙣𝙝𝙤
♱ 𝘃𝗼𝗰𝙚
♱ 𝗽𝗿𝗼𝗰𝘂𝗿𝗮𝗱𝗼
♱ 𝗴𝘂𝗻
♱ 𝗴𝗮𝘆
♱ 𝗴𝗿𝗮𝗳𝗶𝘁𝗶
♱ 𝗽𝗮𝗹𝗵𝗮𝗰𝗼
♱ 𝗰𝗼𝗲𝗹𝗵𝗼

─┅──┅❖ ִ𖤐 ❖─┅──┅   `)
    } 
    let profile = await conn.profilePictureUrl(who, 'image').catch((_) => 'https://telegra.ph/file/24fa902ead26340f3df2c.png')
    
  

const apiUrl = 'https://api.itsrose.rest/image/turnMe';
const authToken = itsrose;



let response = await  fetch('https://api.itsrose.rest/image/turnMe', {
  method: 'POST',
  headers: {
    'accept': 'application/json',
    'Authorization': itsrose,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    "init_image": profile,
    "style": styleId,
    "skin": "default",
    "image_num": 4,
    "prompt": estiloPrompt,
    "strength": 0.57
  })
})
.then(response => {
    console.log(response)
   return response.json()
  
    })
    .then(data => {
      console.log(data)
      if (data.status && data.result && data.result.images) {
    for (let i = 0; i < data.result.images.length; i++) {
       conn.sendFile(m.chat, data.result.images[i], 'error.jpg', null, m);
        
    }
} else {
    console.error('Invalid data format');
    m.react("⚠️")
}
    })
  
  .catch(error => console.error('Error:', error));
   



  
  }
  

 
  
  

  
  
  
  if (!mime) {}
};
handler.help = ['zombie', 'zumbi'];
handler.tags = ['maker'];
handler.command = ['efeito']
handler.level = 23
export default handler;

const getRandom = (ext) => { 
    return `${Math.floor(Math.random() * 10000)}${ext}`;
}